# Testing Coverage Strategy

This document defines the testing coverage strategy for the WhoIsIt backend, explaining which files require unit tests and which are better tested through other means (integration tests, E2E tests, or not tested at all).

## Overview

The backend currently has **162/162 tests passing** with comprehensive test coverage for critical business logic. However, not all files require unit tests - some are better suited for integration or E2E testing, while others (like configuration files) don't need tests at all.

**Coverage Baseline**: 56.79% statements, 54.89% branches

## Testing Strategy by File Type

### ‚úÖ Should Have Unit Tests (Target: 80%+ coverage)

These files contain business logic that should be thoroughly unit tested:

- **Controllers**: HTTP request/response handling, validation
- **Services**: Business logic, data manipulation
- **Guards**: Authorization logic
- **Strategies**: Authentication strategies (JWT, Local)
- **DTOs with validators**: Input validation logic
- **Utilities**: Helper functions and utilities

**Current Status**: ‚úÖ 100% coverage for controllers and most services

### üß™ Should Use Integration Tests

These files involve complex interactions that are better tested with integration tests:

- **Complex game services**: Multi-step workflows
- **Database operations**: TypeORM query interactions
- **WebSocket flows**: Real-time event handling
- **Multi-service workflows**: Services that depend on multiple other services

### üöÄ Should Use E2E Tests

These features should be validated through end-to-end tests:

- **Complete game flows**: Create ‚Üí join ‚Üí play ‚Üí end
- **Authentication flows**: Register ‚Üí verify ‚Üí login ‚Üí logout
- **Real-time Socket.IO events**: Complete WebSocket interactions
- **API endpoint integration**: Full HTTP request/response cycles

### ‚ùå Do Not Need Tests

These files are excluded from coverage requirements:

- **Configuration files**: Module definitions, data source config
- **Type definitions**: TypeScript interfaces and types
- **Database migrations**: Auto-generated schema changes
- **Seed files**: Development utilities
- **Entry points**: Application bootstrap code

---

## Files Excluded from Coverage Requirements

### Application Entry Points

#### `src/main.ts`

**Coverage: 0%** ‚úÖ Expected

**Reason**: Application bootstrap file that only contains NestJS initialization code. Better tested through E2E tests.

**Type**: Entry point  
**Lines**: ~29 lines

---

### Database Files

#### `src/database/data-source.ts`

**Coverage: 0%** ‚úÖ Expected

**Reason**: TypeORM data source configuration. Contains only configuration, no business logic. Tested implicitly when application runs.

**Type**: Configuration  
**Lines**: ~9 lines

#### `src/database/migrations/*.ts`

**Coverage: 0%** ‚úÖ Expected

**Reason**: Database migration files are auto-generated by TypeORM CLI and contain only SQL schema definitions. Validated by running migrations, not unit tests.

**Type**: Auto-generated migration  
**Example**: `1762627880274-InitialSchema.ts` (317 lines)

#### `src/database/seeds/*.ts`

**Coverage: 0%** ‚úÖ Expected

**Reason**: Seed files are utility scripts for populating development/test databases. Not part of production application logic, only run manually.

**Type**: Development utility  

**Files**:

- `seed.ts` - Main seed orchestrator
- `user.seed.ts` - User data seeder
- `character-set.seed.ts` - Character set data seeder
- `reset-db.ts` - Database reset utility
- `index.ts` - Seed exports

---

### Module Configuration Files

#### `src/app.module.ts`

**Coverage: 0%** ‚úÖ Expected (but module is tested via app.module.spec.ts)

**Reason**: Pure module configuration file with no business logic. While module initialization is tested, the file itself contains only decorators and imports.

**Type**: Module configuration  
**Note**: Module initialization IS tested, but the file shows 0% because decorators aren't executed as regular code.

#### `src/database/database.module.ts`

**Coverage: 0%** ‚úÖ Expected

**Reason**: Pure module configuration for database setup. No business logic, only TypeORM configuration.

**Type**: Module configuration

---

### DTO and Response Files

#### `src/game/character-sets/dto/*.ts`

**Coverage: 0%** ‚úÖ Expected

**Reason**: Pure TypeScript interface/type files used for API contracts. These are compile-time constructs with no runtime logic to test.

**Type**: Type definitions  

**Files**:

- `character-response.dto.ts`
- `character-set-response.dto.ts`
- `index.ts`

#### `src/auth/dto/auth-response.dto.ts`

**Coverage: 0%** ‚úÖ Expected

**Reason**: Pure TypeScript interface for API responses. No runtime logic.

**Type**: Type definition

#### `src/auth/types/jwt-payload.type.ts`

**Coverage: 0%** ‚úÖ Expected

**Reason**: TypeScript type definition file. No executable code.

**Type**: Type definition

---

### Guard Files (Tested Implicitly)

#### `src/auth/guards/jwt-auth.guard.ts`

**Coverage: 100%** ‚úÖ Passing

**Reason**: Simple NestJS guard that extends `@nestjs/passport` AuthGuard. Tested implicitly through integration tests and via strategy tests.

**Type**: Passport guard wrapper

#### `src/auth/guards/local-auth.guard.ts`

**Coverage: 100%** ‚úÖ Passing

**Reason**: Simple NestJS guard that extends `@nestjs/passport` AuthGuard. Tested implicitly through integration tests and via strategy tests.

**Type**: Passport guard wrapper

---

### Gateway Type Definitions

#### `src/game/gateway/types.ts`

**Coverage: 0%** ‚úÖ Expected

**Reason**: Type definition file for Socket.IO typed server/client interfaces. No executable code.

**Type**: Type definition

---

## Complex Business Logic Services (Integration Tests Recommended)

The following files have very low unit test coverage (< 20%) because they contain complex business logic that is better validated through integration or E2E tests:

### `src/game/services/game-lobby.service.ts`

**Coverage: 10.07%**  
**Lines**: 384 lines

**Reason**: Large, complex service handling lobby management with intricate game state transitions, player management, and database operations. Unit tests would require extensive mocking that wouldn't provide meaningful validation. Better tested through integration tests.

**Recommendation**: ‚úÖ Focus on integration/E2E tests for this service.

**Key Responsibilities**:

- Player joining/leaving lobbies
- Room code generation and validation
- Player ready state management
- Game start validation
- Complex state transitions

---

### `src/game/services/game-play.service.ts`

**Coverage: 8.65%**  
**Lines**: 859 lines

**Reason**: Core game engine service with complex game flow logic, turn management, and state validation. The interconnected nature of game rules makes isolated unit testing impractical. Integration tests provide better coverage.

**Recommendation**: ‚úÖ Focus on integration/E2E tests for this service.

**Key Responsibilities**:

- Turn management and round progression
- Question/answer validation
- Character elimination logic
- Guess validation and game ending
- Complex game state management
- Win/loss condition checking

---

### `src/game/services/game-stats.service.ts`

**Coverage: 15.62%**  
**Lines**: 314 lines

**Reason**: Statistical calculation service with complex game result aggregation. Better validated with real game data through integration tests.

**Recommendation**: ‚úÖ Focus on integration/E2E tests for this service.

**Key Responsibilities**:

- User statistics calculation
- Player statistics aggregation
- Game event recording
- Leaderboard generation
- Achievement tracking

---

### `src/auth/ws-auth.adapter.ts`

**Coverage: 0%**  
**Lines**: 104 lines

**Reason**: Custom WebSocket authentication adapter that interfaces directly with Socket.IO server internals. Difficult to unit test in isolation without a real Socket.IO server. Better tested through E2E tests.

**Recommendation**: ‚úÖ Focus on E2E tests with real WebSocket connections.

**Key Responsibilities**:

- JWT extraction from cookies/handshake
- User attachment to socket connection
- WebSocket authentication flow
- Socket.IO adapter customization

---

## Summary Statistics

### Files Excluded from Coverage Requirements (0% OK)

**Configuration & Entry Points**: 4 files

- `src/main.ts`
- `src/app.module.ts`
- `src/database/data-source.ts`
- `src/database/database.module.ts`

**Database Utilities**: ~10-15 files

- All files in `src/database/migrations/`
- All files in `src/database/seeds/`

**Type Definitions**: ~8-10 files

- `src/game/character-sets/dto/*.dto.ts`
- `src/auth/dto/auth-response.dto.ts`
- `src/auth/types/*.type.ts`
- `src/game/gateway/types.ts`

**Total Excluded**: ~22-29 files

### Files Best Tested via Integration/E2E Tests (Low Unit Coverage Acceptable)

- `src/game/services/game-lobby.service.ts` (384 lines)
- `src/game/services/game-play.service.ts` (859 lines)
- `src/game/services/game-stats.service.ts` (314 lines)
- `src/auth/ws-auth.adapter.ts` (104 lines)

**Total**: 4 large services (~1,661 lines of complex business logic)

---

## Coverage Goals by File Type

| File Type | Target Coverage | Current Status |
|-----------|----------------|----------------|
| Controllers | 100% | ‚úÖ 100% achieved |
| Simple Services | 90%+ | ‚úÖ Most services covered |
| Strategies | 100% | ‚úÖ 100% achieved |
| Guards | 100% | ‚úÖ 100% achieved |
| DTOs with validators | 100% | ‚úÖ Covered |
| Complex Game Services | 20%+ | ‚ö†Ô∏è 10-15% (by design) |
| WebSocket Adapter | 0%+ | ‚ö†Ô∏è 0% (by design) |
| Config/Migrations | 0% | ‚úÖ 0% (expected) |
| Type Definitions | 0% | ‚úÖ 0% (expected) |

---

## Testing Decision Tree

Use this decision tree to determine the appropriate testing strategy:

```text
Is it a configuration file or type definition?
‚îú‚îÄ YES ‚Üí ‚ùå No tests needed
‚îî‚îÄ NO ‚Üí Continue

Is it a simple controller or service with minimal dependencies?
‚îú‚îÄ YES ‚Üí ‚úÖ Write unit tests (target 80%+)
‚îî‚îÄ NO ‚Üí Continue

Is it a complex service with many dependencies or database interactions?
‚îú‚îÄ YES ‚Üí üß™ Focus on integration tests
‚îî‚îÄ NO ‚Üí Continue

Is it a WebSocket adapter or gateway?
‚îú‚îÄ YES ‚Üí üöÄ Focus on E2E tests with real connections
‚îî‚îÄ NO ‚Üí Continue

Is it a complete user flow or multi-service workflow?
‚îú‚îÄ YES ‚Üí üöÄ Focus on E2E tests
‚îî‚îÄ NO ‚Üí ‚úÖ Write unit tests
```

---

## Testing Best Practices

### Unit Tests ‚úÖ

**When to use**:

- Controllers with simple logic
- Services with isolated business logic
- Guards, strategies, pipes
- Utility functions
- DTO validation

**How to write**:

- Mock all external dependencies
- Test one behavior per test
- Use Arrange-Act-Assert pattern
- Clear, descriptive test names

**Example**: Testing AuthService user registration

### Integration Tests üß™

**When to use**:

- Complex service interactions
- Database operations with real queries
- Multi-service workflows
- Game state transitions

**How to write**:

- Use in-memory database or test database
- Test multiple units together
- Focus on behavior over implementation
- Verify side effects (DB changes, events)

**Example**: Testing complete lobby flow with database

### E2E Tests üöÄ

**When to use**:

- Complete user flows
- API endpoint integration
- WebSocket event flows
- Full authentication flows

**How to write**:

- Use real HTTP requests (supertest)
- Test complete request/response cycle
- Verify cookies, headers, status codes
- Test edge cases and error scenarios

**Example**: Testing complete game flow from create to end

---

## Next Steps for Improving Coverage

### High Priority

1. ‚úÖ **Maintain current 100% controller coverage**
2. ‚úÖ **Maintain current service coverage for simple services**
3. üéØ **Add integration tests for complex game services**
4. üéØ **Add E2E tests for WebSocket flows**

### Medium Priority

1. Add integration tests for:
   - Complete lobby lifecycle
   - Complete gameplay flow
   - Statistics calculation with real data

2. Add E2E tests for:
   - Authentication flows (register ‚Üí verify ‚Üí login)
   - Game flows (create ‚Üí join ‚Üí play ‚Üí end)
   - Real-time WebSocket events

### Low Priority

1. Increase coverage for edge cases in existing tests
2. Add performance tests for critical paths
3. Add load tests for concurrent game sessions

---

## Related Documentation

- [Testing Guide](./testing.md) - Complete testing documentation with examples
- [Debugging Guide](./debugging.md) - How to debug tests
- [Development Workflow](./workflow.md) - Day-to-day development practices
- [Backend Architecture](../backend/README.md) - Understanding the codebase

---

**Last Updated**: November 9, 2025  
**Test Status**: 162/162 tests passing  
**Coverage**: 56.79% statements, 54.89% branches
